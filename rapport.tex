\documentclass[a4paper,10pt]{article}
\usepackage[francais]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}



%opening

\title{\textbf{Algorithme de Huffman } }

\author{Groupe 2 : Poupelin Bastien, Cherruau Anthony, Thebaudin Corentin}
\date{}

\begin{document}


\clearpage
\maketitle
\today
\clearpage
\tableofcontents

\clearpage

\section{Introduction}

\paragraph{David albert Huffman}

\subparagraph{Qui est Huffman?}
\subparagraph{}
Il est un professeur né le 9 août 1925 et mort le 7 octobre 1999. Il est un pionnier dans le domaine informatique. Durant toute sa vie, Huffman apporta des contributions importantes à l'étude des machines à états finis. 
Mais Huffman est principalement connu pour l'invention du codage de Huffman utilisé dans presque toutes les applications qui impliquent la compression et la transmission de données numériques comme les fax, les modems, les réseaux informatiques et la télévision à haute définition.
Huffman contribua beaucoup au développement de différents domaines, notamment dans la théorie de l’information et du codage, où il a été un pionnier dont les découvertes sont à la base des systèmes de compression de fichiers informatiques dans toutes les machines de nos jours.

\paragraph{Principe du codage de huffman}

\subparagraph{}
Le principe du codage de huffman repose sur la création d’un arbre composé de nœuds. Dans une phrase à coder on compte d’abord le nombre d’occurrence de chaque lettre. Chaque caractère constitue donc une feuille de l’arbre auquel on y associe sa valeur d’occurrence.
Puis on crée l’arbre. On associe les deux nœuds ou feuilles avec les occurrences les plus faibles pour créer un nouveau nœud dont son occurrence et la somme des deux occurrences des feuilles. On fait cela jusqu’à qu’il en reste un qui devient la racine.
Ensuite on associe le code 0 pour la branche gauche et le code 1 pour la branche droite. Ainsi pour obtenir le code binaire de chaque caractère on parcours l’arbre à partir de la racine jusqu’au feuilles en rajoutant un 0 ou un 1 en fonction de la branche suivie.

\section{Compter la fréquence des caractères}
\subsection{sous partie}

\section{Arbre}
\subsection{Principe}

La création de l’arbre se fait en parcourant la liste trié. Elle prend les deux premières valeurs de la liste créer les feuilles puis va créer un nœud et donc un arbre. 
Le nœud est crée en prenant les deux feuilles qui sont le fils gauche et le fils droit du nœud. Le nœud a pour valeur la somme des fréquences de ses fils. 
Ensuite on va réitérer cela a toute les valeurs de la liste.

\subsection{Structure pour l'arbre}
\paragraph{Description}
\subparagraph{}
L'arbre contient la fréquence des lettres et les lettres qui vont nous permettre de créer les feuilles et les noeuds.
Enfin on a une structure fils gauche et fils droit pour les noeuds ou le fils fauche et le fils droit vont pointer vers un noeud ou une feuille.

\subsection{Création de l'arbre}
\subparagraph{}
La création de l'arbre se fait en parcours la liste trié. Si l'élément suivant de la liste est différent de nulle 
alors on regarde si l'arbre est nulle ou non. Si c'est le cas alors on va créer le premier noeud avec les deux premières valeur de la liste trié.
Si ce n'est pas le cas alors on va regarder les fréquences dans la liste. Si la valeur de la fréquence est identique alors on va créer un noeud et on le met dans un autre arbre.
Sinon on crée un noeud avec le premier noeud puis on assemble les deux arbres. A la fin il reste une valeur et donc on va créer la racine avec l'arbre.

\subsection{Réalisation d'un dictionnaire listant le codage de chaque caractère}
\subparagraph{}
Ce bloc permettra de coder chaque caractère du fichier à compresser en binaire. C'est cette opération que l'on appellera compression du document.

Pour réaliser ce bloc, il faudra utiliser l'arbre créé auparavant dans le bloc 2. Grâce à cet arbre, on pourra coder chaque caractère en binaire suivant le chemin emprunté dans l'arbre.
Par exemple ici, on établira que pour chaque chemin vers la gauche emprunté, un "0" sera codé pour le caractère trouvé. Lorsque le chemin emprunté est celui du fils droit, le codage sera un "1".

C'est pourquoi la réalisation de ce bloc se basera sur une boucle de lecture de l'arbre. En premier temps la réalisation de cette lecture serait faite de manière préfixe, avec une variable binaire qui contiendrait le codage du caractère, s'incrémentant par un décalage de bit à chaque mouvement dans l'arbre jusqu'à attendre une feuille. Par soucis de temps et de solutions, un second choix a été réalisé: L'arbre sera lu de haut en bas jusqu'à atteindre une feuille, le codage et le caractère sera écrit dans le fichier puis la feuille sera supprimée. La lecture sera relancée, jusqu'à ce que l'arbre soit vide.


\section{Compression}
\subsection{Principe}
Après avoir réalisé ces 3 blocs, nous avons à disposition tout les outils pour réaliser la compression et la décompression d'un fichier.

La compression consiste à lire le fichier à compresser et remplacer chaque caractère par son codage listé dans le dictionnaire.

\section{Décompression}
\subsection{Principe}
\subparagraph{}
La décompression va lire le fichier compressé qui contient une en-tête et le fichier texte compressé. L'en-tête contient l'arbre crée précédement.
Pour décompresser le fichier on lit le fichier qui contient des 1 et des 0 puis on parcours l'arbres. Dés que l'on arrive a une feuille dans l'arbre alors on mets la lettre trouvé dans 
le fichier décompressé et on continue ainsi jusqu'à la fin du fichier.

(A voir) La décompression peut se faire de 2 manières: l'en-tête peut contenir le dictionnaire et donc on lira le fichier compressé et on retrouvera le caractère correspondant au codage. Cette méthode est plus simple à réaliser pour l'en-tête, mais un peu plus complexe pour la décompression.
La seconde méthode consiste à intégrer l'arbre dans l'en-tête, et on retrouvera le caractère en suivant le chemin suivi avec le codage du fichier compressé. Cette méthode est plus complexe pour intégrer l'arbre à l'en-tête, mais plus simple à la suite pour décompresser le fichier.

\section{Comparaison différente compression}


\section{Amélioration}

Notre code est minimaliste et de nombreux point peut être amélioré.

\subparagraph{encodage :}
L'encodage actuelle ne prend pas les accents et donc dans notre langue le français cela est problèmatique.
Notre programme prend donc que des caractères non accentués.
\end{document}
